**Lead Auditors**

[0kage](https://twitter.com/0kage_eth)

[Immeas](https://twitter.com/0ximmeas)

**Assisting Auditors**



---

# Findings
## Medium Risk


### Cross-chain token transfer from `SpokeVault` fails due to approval from implementation contract instead of proxy

**Description:** [`SpokeVault`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/src/SpokeVault.sol)는 스마트 M으로부터 초과 M 토큰을 보유하는 컨트랙트이며, [`SpokeVault::transferExcessM`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/src/SpokeVault.sol#L69-L89)을 통해 이 초과분을 메인넷의 `HubVault`로 전송할 수 있습니다.

이를 가능하게 하기 위해, [`SpokeVault` 생성자](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/src/SpokeVault.sol#L63-L64)에서 무한 승인(infinite approval)이 설정됩니다:
```solidity
// Approve the SpokePortal to transfer M tokens.
IERC20(mToken).approve(spokePortal_, type(uint256).max);
```

하지만 `SpokeVault`는 [`DeployBase::_deploySpokeVault`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/script/deploy/DeployBase.sol#L221-L235)에서 볼 수 있듯이 프록시로 배포됩니다:
```solidity
spokeVaultImplementation_ = address(
    new SpokeVault(spokePortal_, hubVault_, destinationChainId_, migrationAdmin_)
);

spokeVaultProxy_ = _deployCreate3Proxy(address(spokeVaultImplementation_), _computeSalt(deployer_, "Vault"));
```
여기서 [`_deployCreate3Proxy`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/script/helpers/Utils.sol#L102-L108)는 `ERC1967Proxy`를 배포합니다.

결과적으로 생성자에서 설정된 승인은 토큰을 보유하고 전송을 시작하는 프록시가 아니라 구현 컨트랙트에만 적용됩니다.

**Impact:** `Portal`은 토큰을 전송하기 위해 승인이 필요하므로 `SpokeVault::transferExcessM`은 의도한 대로 작동하지 않습니다. `SpokeVault`에 있는 M 토큰은 사실상 갇히게 되지만, 컨트랙트가 업그레이드 가능하므로 영구적으로 갇히는 것은 아닙니다.

**Proof of Concept:** [`MockSpokePortal::transfer`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/test/mocks/MockSpokePortal.sol#L14-L21)에 토큰 전송을 추가하면 [`SpokeVaultTests::test_transferExcessM`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/test/unit/Spokevault.t.sol#L115-L138)이 실패하게 됩니다:
```diff
+import { IERC20 } from "../../lib/common/src/interfaces/IERC20.sol";
...
    function transfer(
        uint256 amount,
        uint16 recipientChain,
        bytes32 recipient,
        bytes32 refundAddress,
        bool shouldQueue,
        bytes memory transceiverInstructions
    ) external payable returns (uint64) {
+       IERC20(mToken).transferFrom(msg.sender, address(this), amount);
    }
```

**Recommended Mitigation:** 생성자에서 승인을 제거하고 `transferExcessM`에서 필요할 때만 토큰 승인을 설정하는 것을 고려하십시오:
```diff
+ IERC20(mToken).approve(spokePortal_, amount_);
  messageSequence_ = INttManager(spokePortal).transfer{ value: msg.value }(
      amount_,
      destinationChainId,
      hubVault_,
      refundAddress_,
      false,
      new bytes(1)
   );
```
또한 이 접근 방식은 업그레이드 가능한 컨트랙트에 대한 무한 승인을 제거하여 보안을 강화합니다.

**M0 Foundation**
커밋 [78ac49b](https://github.com/m0-foundation/m-portal/commit/78ac49bba3ac294873a949eec00a5bfad8b41c34)에서 수정됨

**Cyfrin**
확인됨


### SpokeVault transfers will frequently revert due to Wormhole gas fee fluctuations

**Description:** `SpokeVault.transferExcessM()` 함수는 웜홀(Wormhole) 가스비를 지불하기 위해 ETH를 전달하지만, `SpokeVault`에는 ETH 환불을 받을 수 있는 기능이 없기 때문에 초과로 전송된 ETH는 트랜잭션을 되돌리게(revert) 합니다. 현재 구현은 사용자가 트랜잭션 시점의 정확한 웜홀 가스비와 동일한 수수료를 보내는 경우에만 작동합니다.

이는 사용자가 오프체인에서 수수료를 계산하는 시점과 트랜잭션이 실제로 실행되는 시점 사이에 웜홀 가스비가 변동될 수 있기 때문에 심각한 사용성 문제를 야기합니다.

`ManagerBase::_prepareForTransfer`의 다음 코드는 가스비가 부족하면 트랜잭션이 되돌려짐을 보여줍니다. 또한 배송비(delivery fee)보다 많은 초과 가스비는 발신자에게 환불됩니다.

```solidity
// In ManagerBase.sol
function _prepareForTransfer(...) internal returns (...) {
    // ...
    if (msg.value < totalPriceQuote) {
        revert DeliveryPaymentTooLow(totalPriceQuote, msg.value);
    }

    uint256 excessValue = msg.value - totalPriceQuote;
    if (excessValue > 0) {
        _refundToSender(excessValue); // Reverts as SpokeVault can't accept ETH
    }
}

  function _refundToSender(
        uint256 refundAmount
    ) internal {
        // refund the price quote back to sender
        (bool refundSuccessful,) = payable(msg.sender).call{value: refundAmount}("");
         //@audit excess gas fee sent back to msg.sender (SpokeVault)

        // check success
        if (!refundSuccessful) {
            revert RefundFailed(refundAmount);
        }
    }
```


결과적으로 `transferExcessM`은 사용자가 정확한 수수료를 전송할 때만 실행될 수 있습니다. 이렇게 하는 것은 다음과 같은 이유로 어렵습니다:

- 이 함수는 누구나 호출할 수 있으므로 일반 사용자가 배송비를 계산하는 방법을 모를 가능성이 높습니다.
- 사용자가 오프체인에서 정확한 수수료를 계산하더라도 자연스러운 가스비 변동으로 인해 트랜잭션이 실패할 가능성이 매우 높습니다.


**Impact:** 견적과 실행 사이에 가스비가 조금이라도 증가하거나 감소하면 트랜잭션이 되돌려집니다.

**Proof of Concept**
`MockSpokePortal`을 다음과 같이 변경하고 `SpokeVault.t.sol`에서 아래 테스트를 실행하십시오:

```solidity
      contract MockSpokePortal {
          address public immutable mToken;
          address public immutable registrar;

          constructor(address mToken_, address registrar_) {
              mToken = mToken_;
              registrar = registrar_;
          }

          function transfer(
              uint256 amount,
              uint16 recipientChain,
              bytes32 recipient,
              bytes32 refundAddress,
              bool shouldQueue,
              bytes memory transceiverInstructions
          ) external payable returns (uint64) {

              // mock return of excess fee back to sender
              if(msg.value > 1) {
                  payable(msg.sender).transfer(msg.value-1);
              }

          }
      }

   contract SpokeVaultTests is UnitTestBase {
        function testFail_transferExcessM() external { //@audits fails with excess fee
            uint256 amount_ = 1_000e6;
            uint256 balance_ = 10_000e6;
            uint256 fee_ = 2;
            _mToken.mint(address(_vault), balance_);
            vm.deal(_alice, fee_);

            vm.prank(_alice);
            _vault.transferExcessM{ value: fee_ }(amount_, _alice.toBytes32());
        }
   }

```

**Recommended Mitigation:** 웜홀은 초과 가스비를 발신자에게 환불하는 구체적인 조항을 가지고 있습니다. 이는 자연스러운 가스비 변동에도 불구하고 전송의 신뢰성을 보장하기 위해 마련되었습니다.

`SpokeVault`에 `payable receive()` 함수를 추가하여 초과 ETH 환불을 처리하도록 `SpokeVault.transferExcessM()` 함수를 업데이트하는 것을 고려하십시오. 또한 수신된 모든 ETH를 원래 호출자에게 다시 전달하는 로직을 반드시 포함해야 합니다. 그렇지 않으면 초과 가스비가 `SpokeVault` 안에 갇히게 됩니다.

**M0 Foundation**
커밋 [78ac49b](https://github.com/m0-foundation/m-portal/commit/78ac49bba3ac294873a949eec00a5bfad8b41c34)에서 수정됨

**Cyfrin**
확인됨

\clearpage
## Informational


### `ExcessMTokenSent` event logs `messageSequence_` as `0` incorrectly

**Description:** `SpokeVault`에서 초과 M 토큰을 전송하기 위해 [`SpokeVault::transferExcessM`](https://github.com/m0-foundation/m-portal/blob/8f909076f4fc1f22028cabd6df8a9e6b5be4b078/src/SpokeVault.sol#L69-L89)을 호출할 때, `ExcessMTokenSent` 이벤트가 방출됩니다:
```solidity
) external payable returns (uint64 messageSequence_) {
    ...

    // @audit messageSequence_ not assigned yet
    emit ExcessMTokenSent(destinationChainId, messageSequence_, msg.sender.toBytes32(), hubVault_, amount_);

    messageSequence_ = INttManager(spokePortal).transfer{ value: msg.value }(
        ...
    );
}
```
그러나 이벤트가 방출되는 시점에 `messageSequence_` 값은 아직 할당되지 않았으므로 항상 0이 됩니다.

**Recommended Mitigation:** `messageSequence_`가 유효한 값으로 할당된 후인 `transfer` 호출 다음에 이벤트를 방출하는 것을 고려하십시오.

**M0 Foundation**
커밋 [78ac49b](https://github.com/m0-foundation/m-portal/commit/78ac49bba3ac294873a949eec00a5bfad8b41c34)에서 수정됨

**Cyfrin**
확인됨

\clearpage
