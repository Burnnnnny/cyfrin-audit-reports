**Lead Auditors**

[Immeas](https://twitter.com/0ximmeas)

**Assisting Auditors**

[Immeas](https://twitter.com/0ximmeas)


---

# Findings
## Critical Risk


### 콜백 구현 누락으로 인해 `GMXV2_Module` 인출 기능이 손상됨 (`GMXV2_Module` withdrawal functionality is broken due to missing callback implementation)

**설명:** `GMXV2_Module` 계약의 인출 기능은 필요한 콜백 인터페이스를 구현하지 않고 자신(**`address(this)`**)을 GMX V2 인출에 대한 콜백 계약으로 설정하기 때문에 손상되었습니다. 이로 인해 모든 인출 트랜잭션이 revert되어 사용자의 자금이 프로토콜에 사실상 묶이게 됩니다.

```solidity
function gmxv2_withdraw(
    address market,
    uint256 executionFee,
    uint256 amount,
    uint256 minLongOut,
    uint256 minShortOut
) external payable onlyRole(EXECUTOR_ROLE) nonReentrant {
    IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({
        receiver: address(this),
        callbackContract: address(this),  // @audit - Setting callback without implementation
        // ...
    });
    // ...
}
```

GMX V2의 문서 및 소스 코드에 따르면, 콜백 계약이 지정된 경우 두 가지 중요한 함수를 구현해야 합니다:

1. `afterWithdrawalExecution(bytes32, WithdrawalUtils.Props, EventUtils.EventLogData)`
2. `afterWithdrawalCancellation(bytes32, WithdrawalUtils.Props)`

이러한 콜백은 GMX의 `ExecuteWithdrawalUtils.sol`에 의해 강제됩니다:

```solidity
// In ExecuteWithdrawalUtils.sol
function executeWithdrawal(...) {
    // ... other code ...
    CallbackUtils.afterWithdrawalExecution(params.key, withdrawal, eventData);
    // ... other code ...
}

// In CallbackUtils.sol
function afterWithdrawalExecution(...) internal {
    if (withdrawal.callbackContract() != address(0)) {
        IWithdrawalCallbackReceiver(withdrawal.callbackContract()).afterWithdrawalExecution(
            key,
            withdrawal,
            eventData
        );
    }
}
```


**영향:** 이 문제는 핵심 프로토콜 기능을 완전히 손상시킵니다. 심각한 의미가 있습니다:

- **기능의 완전한 손실**: `gmxv2_withdraw`를 통한 모든 인출 트랜잭션이 revert되어 사용자가 자금을 인출할 수 없게 됩니다.
- **자금 손실**: 사용자 자금이 프로토콜에 잠기게 됩니다.



**개념 증명 (Proof of Concept):** 이 문제를 보여주는 테스트를 만들었습니다:

```solidity
function test_gmxv2_withdraw_RevertGivenMissingCallback() public {
        // First make a deposit to get market tokens
        uint256 depositAmount = 1e18;
        deal(WETH_ADDRESS, address(strategy), depositAmount);
        vm.prank(address(strategy));
        _weth.approve(GMX_DEPOSIT_VAULT, depositAmount);

        // Store initial balance
        uint256 initialExecutorBalance = EXECUTOR.balance;

        // Get market info before deposit
        IMarket.Props memory marketInfo = IReader(GMX_READER).getMarket(GMX_DATASTORE, GMX_WETH_MARKET);
        address marketToken = marketInfo.marketToken;

        // Execute deposit
        vm.prank(EXECUTOR);
        _gmx.gmxv2_deposit{value: 0.1 ether}(
            GMX_WETH_MARKET,
            0.1 ether,  // execution fee
            depositAmount,
            0,          // no short token
            0           // min out
        );

        // Deal market tokens to the vault first before simulating keeper execution
        deal(marketToken, GMX_DEPOSIT_VAULT, depositAmount);

        // ============ KEEPER SIMULATION - DEPOSIT EXECUTION ============
        // In production: GMX keeper would execute this step
        // Here we simulate the keeper minting market tokens to the strategy
        vm.prank(GMX_DEPOSIT_VAULT);
        IERC20(marketToken).transfer(address(strategy), depositAmount); // Simulate market tokens being minted
        // ============ END KEEPER SIMULATION - DEPOSIT EXECUTION ============

        // Get market token balance after deposit
        uint256 marketTokenBalance = IERC20(marketToken).balanceOf(address(strategy));

        require(marketTokenBalance > 0, "No market tokens received from deposit");

        // Approve market tokens for withdrawal
        vm.prank(address(strategy));
        IERC20(marketToken).approve(GMX_WITHDRAW_VAULT, depositAmount);

        // Now attempt to withdraw
        vm.prank(EXECUTOR);
        _gmx.gmxv2_withdraw{value: 0.1 ether}(
            GMX_WETH_MARKET,
            0.1 ether,  // execution fee
            depositAmount,
            0,          // min long out
            0           // min short out
        );

        // Deal WETH to the withdraw vault before simulating keeper execution
        deal(WETH_ADDRESS, GMX_WITHDRAW_VAULT, depositAmount * 2); // Ensure vault has enough WETH

        // First give market tokens to the strategy
        deal(marketToken, address(strategy), depositAmount);

        // ============ KEEPER SIMULATION - WITHDRAWAL EXECUTION ============
        // In production: GMX keeper would:
        // 1. Burn market tokens
        // 2. Return WETH
        // 3. Call the callback contract (if set) with afterWithdrawalExecution
        // Here we simulate steps 1 and 2 manually:
        vm.startPrank(GMX_WITHDRAW_VAULT);
        // Step 1: Burn market tokens (transfer them to withdraw vault)
        IERC20(marketToken).transferFrom(address(strategy), GMX_WITHDRAW_VAULT, depositAmount);
        // Step 2: Return WETH to strategy
        IERC20(WETH_ADDRESS).transfer(address(strategy), depositAmount);
        vm.stopPrank();
        // Note: Step 3 (callback) is not simulated as we're bypassing GMX's actual execution
        // ============ END KEEPER SIMULATION - WITHDRAWAL EXECUTION ============


        // Verify executor spent the execution fees
        assertEq(
            EXECUTOR.balance,
            initialExecutorBalance - 0.2 ether, // 0.1 for deposit + 0.1 for withdrawal
            "Executor should have spent 0.2 ETH for execution fees"
        );
    }
```

테스트는 통과하지만, 이는 키퍼(keeper)의 작업을 수동으로 시뮬레이션하고 있기 때문에 오해의 소지가 있습니다. 프로덕션 환경에서, [GMX V2의 문서](https://github.com/gmx-io/gmx-synthetics#withdrawal-notes)에 따르면 인출에는 특정 콜백 처리가 필요합니다:

> "CONTROLLER 역할이 있는 핸들러만 afterWithdrawalExecution 및 afterWithdrawalCancellation 콜백 함수를 호출할 수 있도록 하세요"

이는 GMX V2가 인출과 상호 작용하는 계약이 이러한 콜백 함수를 구현할 것으로 예상함을 나타냅니다. 프로덕션에서 계약이 인출을 시도할 때:
1. 키퍼는 계약에서 `afterWithdrawalExecution`을 호출하려고 시도합니다.
2. 이 인터페이스를 구현하지 않으므로 트랜잭션이 revert됩니다.
3. 인출이 실패하여 사용자 자금이 프로토콜에 갇히게 됩니다.

필수 콜백 메커니즘을 건너뛰고 토큰 전송을 수동으로 시뮬레이션하여 GMX의 실제 인출 실행을 우회하기 때문에 테스트가 통과하는 것입니다.

**권장 완화 방법:** 두 가지 가능한 수정 사항이 있습니다:

**옵션 1: 콜백 제거 (권장)**
인출 후 처리가 필요하지 않은 경우:

```solidity
IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({
    receiver: address(this),
    callbackContract: address(0),  // Set to zero address to skip callbacks
    // ...
});
```

**옵션 2: 콜백 인터페이스 구현**
인출 후 처리가 필요한 경우 IWithdrawalCallbackReceiver 인터페이스를 구현하세요:

```solidity
contract GMXV2_Module is IGMXV2_Module, IWithdrawalCallbackReceiver {
    function afterWithdrawalExecution(
        bytes32 key_,
        WithdrawalUtils.Props memory withdrawal_,
        EventUtils.EventLogData memory eventData_
    ) external {
        // Add post-withdrawal logic
    }

    function afterWithdrawalCancellation(
        bytes32 key_,
        WithdrawalUtils.Props memory withdrawal_
    ) external {
        // Add cancellation logic
    }
}
```

인출 후 처리에 대한 특별한 요구가 없는 한 더 간단하고 가스가 덜 필요한 옵션 1(콜백 제거)을 권장합니다.


**D2:** [`37df474`](https://github.com/d2sd2s/d2-contracts/commit/37df474519e033f01939df7dfef55ad3370bd26d)에서 수정됨.

**Cyfrin:** 검증됨.


### `makefile` 파일에 `PRIVATE_KEY` 및 기타 민감한 데이터가 노출됨 (`PRIVATE_KEY` exposed in `makefile` file and other sensitive data)

**설명:** 프로젝트의 Makefile에는 다음을 포함하여 하드코딩된 민감한 자격 증명이 포함되어 있습니다:

- 계약 배포에 사용되는 개인 키
- API 키가 포함된 여러 RPC 엔드포인트 URL
- 다양한 네트워크에 대한 여러 Etherscan API 키

**영향:** 고객 자금이 위험에 처하지 않았고 배포자 키가 배포된 전략에 대한 관리자 권한이 없었지만, 다음과 같은 이유로 이 노출은 치명적입니다:

1. 개인 키는 관련 주소에 대한 완전한 제어 권한을 부여하며, 여기에는 다음이 포함됩니다:
    - 지갑이 보유한 자금에 대한 전체 액세스
    - 프로토콜을 가장하고 가짜 볼트 배포
2. RPC 엔드포인트는 다음과 같은 용도로 사용될 수 있습니다:
    - 승인되지 않은 API 호출 실행
    - 프로젝트에 비용 발생 가능성
    - 프로덕션 서비스에 영향을 미치는 속도 제한 초과

**권장 완화 방법:** 필요한 즉각적인 조치:
- 노출된 모든 자격 증명을 즉시 제거하세요.
- 손상된 주소에서 자산을 전송하세요.
- 주소에서 계약 권한을 취소하세요.
- 모든 API 키를 다시 생성하세요.

미래의 완화를 위해 이 Updraft [레슨](https://updraft.d2sd2s.io/courses/foundry/foundry-simple-storage/never-use-a-env-file?lesson_format=video)의 방법을 사용하여 개인 키를 안전하게 저장하세요.

**D2:** [`a4f3517`](https://github.com/d2sd2s/d2-contracts/commit/a4f3517d7c410278c1703b89aaad2315b5b86ba7) 및 [`228d0e17`](https://github.com/d2sd2s/d2-contracts/commit/228d0e17a1574d704380c3106a8d0caf6143ffd7)에서 수정됨.

**Cyfrin:** 검증됨.

\clearpage
## High Risk


### ERC-4626 볼트 토큰을 크로스 체인으로 전송할 때 사용자가 가치를 잃을 수 있음 (Users may lose value when transferring ERC-4626 Vault tokens cross-chain)

**설명:** `VaultV0` 및 `VaultV3` ERC-4626 토큰은 모두 체인 간에 전송 가능하도록 설계되었으므로 LayerZero 크로스 체인 OFT 표준을 구현합니다.

토큰이 크로스 체인으로 전송될 때, 소스 체인에서 토큰을 "제거"하는 방법을 결정하기 위해 `_debit` 함수가 호출됩니다. 이에 대한 두 가지 표준 접근 방식은 **잠금/잠금 해제(Lock/Unlock)**와 **발행/소각(Mint/Burn)**입니다. `VaultV0`와 `VaultV3`는 [`VaultV0::_debit` 및 `VaultV0::_credit`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/VaultV0.sol#L384-L393)에서 볼 수 있듯이 **발행/소각** 접근 방식을 구현합니다 ([`VaultV3`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/VaultV3.sol#L321-L330)에서도 동일한 구현):

```solidity
function _debit(address _from, uint256 _amountLD, uint256 _minAmountLD, uint32 _dstEid) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {
    (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);
    _burn(_from, amountSentLD);
}

function _credit(address _to, uint256 _amountLD, uint32) internal virtual override returns (uint256 amountReceivedLD) {
    if (_to == address(0x0)) _to = address(0xdead);
    _mint(_to, _amountLD);
    return _amountLD;
}
```

그러나 이 접근 방식은 `_burn`이 `totalSupply`를 줄이기 때문에 ERC-4626 볼트에 문제가 됩니다. 주식 가치는 `assets / totalSupply`로 계산되므로 토큰을 다른 체인으로 전송하면 볼트의 원래 체인에 토큰이 남아 있는 스테이커의 주식 가치가 증가합니다. 즉, 이러한 스테이커가 인출하면 원래 토큰을 크로스 체인으로 전송한 사용자에게 속했던 자산의 일부를 받게 됩니다.

**영향:** 크로스 체인 전송은 볼트의 주식 가치를 왜곡합니다. 토큰을 전송하는 사용자는 토큰이 전송 중인 동안 다른 사용자가 인출할 경우 가치의 일부 또는 전부를 잃을 위험이 있습니다.

**개념 증명 (Proof of Concept):** 다음 테스트는 문제를 보여줍니다. `VaultV3`에 대해서도 유사한 테스트가 작성되었습니다:
```solidity
function test_vaultV0_xchain_transfer_affects_vault_exchange_rate() public {
    deal(address(asset), DEPOSITOR, 2e18);

    // 1. Bob and Alice both participate in the vault
    vm.startPrank(DEPOSITOR);
    asset.approve(address(vault), 2e18);
    vault.deposit(1e18, ALICE);
    vault.deposit(1e18, BOB);
    assertEq(vault.balanceOf(ALICE), 1e18);
    assertEq(vault.balanceOf(BOB), 1e18);
    vm.stopPrank();

    // 2. Share price is not 1 to 1
    assertEq(vault.previewRedeem(1e18), 1e18);

    SendParam memory sendParam;
    sendParam.to = bytes32(uint256(1));
    sendParam.amountLD = 1e18;

    MessagingFee memory fee;

    // 3. Bob transfers his share to another chain
    vm.prank(BOB);
    vault.send(sendParam, fee, BOB);

    // Since the share is burnt on the source chain, share price has increased
    assertEq(vault.previewRedeem(1e18), 2e18);

    // 4. Alice redeems her share, getting Bobs share as well
    vm.prank(ALICE);
    vault.redeem(1e18,ALICE, ALICE);

    assertEq(vault.balanceOf(ALICE), 0);
    assertEq(asset.balanceOf(ALICE), 2e18);

    Origin memory origin;
    origin.sender = bytes32(uint256(1));
    (bytes memory message,) = OFTMsgCodec.encode(
        bytes32(uint256(uint160(BOB))),
        1e6,
        ""
    );

    // 5. Bob transfers back
    vm.prank(LZ_ENDPOINT);
    vault.lzReceive(
        origin,
        bytes32(uint256(0)),
        message,
        LZ_ENDPOINT,
        ""
    );

    // Bobs share is now worth nothing as Alice has redeemed it
    assertEq(vault.balanceOf(BOB), 1e18);
    assertEq(vault.previewRedeem(1e18), 0);

    vm.prank(BOB);
    vm.expectRevert("ZERO_ASSETS");
    vault.redeem(1e18, BOB, BOB);
}
```

**권장 완화 방법:** **잠금/잠금 해제(Lock/Unlock)** 접근 방식을 사용하고 전송 시 자금을 볼트에 보관하는 것을 고려하세요:
```solidity
function _debit(address _from, uint256 _amountLD, uint256 _minAmountLD, uint32 _dstEid) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {
    (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);
    // Instead of burning, transfer to this contract
    _transfer(_from, address(this), amountSentLD);
}

function _credit(address _to, uint256 _amountLD, uint32) internal virtual override returns (uint256 amountReceivedLD) {
    if (_to == address(0x0)) _to = address(0xdead);
    _transfer(address(this),_to, _amountLD);
    return _amountLD;
}
```

**D2:** [`21f2dd1`](https://github.com/d2sd2s/d2-contracts/commit/21f2dd1bd0c613b51cadeb5feafa58ed5ad02b6e) 및 [`902a14b`](https://github.com/d2sd2s/d2-contracts/commit/902a14bb4ab3a036b286253bd68f57f581c2a2d2)에서 수정됨.

**Cyfrin:** 검증됨.


### 잘못된 인터페이스로 인해 Berachain RewardVaults에 대한 보상 청구가 실패함 (Reward claiming fails for Berachain RewardVaults due to incorrect interface)

**설명:** D2는 새로운 [유동성 증명(Proof-of-Liquidity)](https://docs.berachain.com/learn/what-is-proof-of-liquidity) 모델에서 작동하는 새로 출시된 Berachain에 배포할 계획입니다. Berachain에서 유동성 제공자는 LP 토큰을 [보상 볼트(Reward Vaults)](https://docs.berachain.com/developers/contracts/reward-vault)에 스테이킹하여 Berachain 거버넌스 토큰인 `$BGT`를 얻을 수 있습니다.

스테이킹 및 인출을 용이하게 하기 위해 D2 [`Bera_Module`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol)에는 [`Bera_Module::bera_vault_stake`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L66-L68) 및 [`Bera_Module::bera_vault_withdraw`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L70-L72) 함수가 포함되어 있습니다. `$BGT` 보상을 청구하려면 [`Bera_Module::bera_vault_get_reward`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L74-L76) 함수가 사용됩니다:

```solidity
function bera_vault_get_reward(address token) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    IVault(vaultFactory.getVault(token)).getReward(address(this));
}
```

그러나 [`IVault::getReward`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L221)에 사용된 인터페이스가 올바르지 않습니다:

```solidity
function getReward(address account) external;
```

Berachain의 [`RewardVault::getReward`](https://github.com/berachain/contracts/blob/main/src/pol/rewards/RewardVault.sol#L318-L321) 및 온체인에 배포된 대로 올바른 함수 서명은 다음과 같습니다:

```solidity
function getReward(
    address account,
    address recipient
)
```

이 불일치로 인해 `Bera_Module::bera_vault_get_reward`에 대한 모든 호출은 revert되어 `$BGT` 보상이 청구되는 것을 방지합니다.

**영향:** Berachain의 유동성 증명 모델의 핵심 인센티브인 `$BGT` 보상을 청구할 수 없습니다. 이는 Berachain의 보상 시스템에 효과적으로 참여할 수 있는 프로토콜의 능력을 감소시킵니다. 또한 이러한 보상은 프로토콜의 전체 수입에 기여합니다.

**개념 증명 (Proof of Concept):** 다음 테스트는 문제를 강조합니다:
```solidity
function test_bera_vault_get_reward() public {
    deal(USDCe_HONEY_STABLE_ADDRESS, address(strategy), 1e18);

    vm.startPrank(EXECUTOR);
    trader.approve(USDCe_HONEY_STABLE_ADDRESS, USDCe_HONEY_STABLE_VAULT, 1e18);
    bera.bera_vault_stake(USDCe_HONEY_STABLE_ADDRESS, 1e18);

    assertEq(RewardVault(USDCe_HONEY_STABLE_VAULT).balanceOf(address(strategy)), 1e18);

    vm.warp(block.timestamp + 1 days);

    // there are rewards to be claimed
    assertGt(RewardVault(USDCe_HONEY_STABLE_VAULT).earned(address(strategy)), 0);

    // rewards cannot be claimed due to the interface definition being wrong
    vm.expectRevert();
    bera.bera_vault_get_reward(USDCe_HONEY_STABLE_ADDRESS);

    vm.stopPrank();
}
```

**권장 완화 방법:** 인터페이스에 추가 매개변수를 추가하고 `address(this)`로 호출하는 것을 고려하세요:
```diff
-   IVault(vaultFactory.getVault(token)).getReward(address(this));
+   IVault(vaultFactory.getVault(token)).getReward(address(this), address(this));
```

**D2:** [`92303a6`](https://github.com/d2sd2s/d2-contracts/commit/92303a61653ff5564df0c143afcd7298e14a33b9)에서 수정됨.

**Cyfrin:** 검증됨.

\clearpage
## Medium Risk


### 슬리피지 보호가 부족하여 Pendle 거래 악용 허용 (Lack of slippage protection allows exploitation of Pendle trades)

**설명:** [`Pendle_Module`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol)은 Pendle 프로토콜과 상호 작용하도록 설계되었습니다. [Pendle](https://pendle.finance/)은 사용자가 다양한 수익 관리 전략을 실행할 수 있는 무허가 수익 거래 프로토콜입니다. 다양한 수익 구성 요소 간의 거래를 용이하게 하기 위해 `PT`, `YT`, `SY`와 같은 다양한 토큰 유형의 복잡한 시스템을 활용합니다.

Pendle 내에서 사용자는 자산을 예치하여 이러한 토큰을 받고 나중에 그들 간에 스왑할 수 있습니다. `Pendle_Module` 패싯(facet)은 이러한 기능을 구현합니다.

그러나 문제는 슬리피지 매개변수가 여러 함수에서 `0`으로 하드코딩되어 있기 때문에 슬리피지 보호가 완전히 없다는 것입니다:
* [`Pendle_Module::pendle_deposit`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L35-L74), [L69](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L69):
  ```solidity
  router.addLiquiditySingleToken(
      address(this),
      address(market),
      0, // @audit `minLpOut` hardcoded to 0
      approxParams,
      input,
      limitOrderData
  );
  ```
* [`Pendle_Module::pendle_withdraw`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L76-L107), [L86](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L86):
  ```solidity
  IPRouter.TokenOutput memory output = IPRouter.TokenOutput({
      tokenOut: ast,
      minTokenOut: 0, // @audit `minTokenOut` hardcoded to 0
      tokenRedeemSy: ast,
      pendleSwap: address(0),
      swapData: swapData
  });
  ```
* [`Pendle_Module::pendle_swap`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L109-L188), [L140](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L140), [L150](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L150) 및 [L170](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L170):
  ```solidity
  IPRouter.TokenOutput memory output = IPRouter.TokenOutput({
      tokenOut: ast,
      minTokenOut: 0, // @audit `minTokenOut` hardcoded to 0
      tokenRedeemSy: ast,
      pendleSwap: address(0),
      swapData: swapData
  });
  ```
  ```solidity
  router.swapExactTokenForPt(
      address(this),
      market,
      0, // @audit `minPtOut` hardcoded to 0
      approxParams,
      input,
      limitOrderData
  );
  ```
  ```solidity
  router.swapExactTokenForYt(
      address(this),
      market,
      0, // @audit `minYtOut` hardcoded to 0
      approxParams,
      input,
      limitOrderData
  );
  ```
* [`Pendle_Module::pendle_claim`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L190-L200), [L197](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L197):
  ```solidity
  IPSY(sy).redeem(
      address(this),
      IERC20(sy).balanceOf(address(this)),
      IPSY(sy).getTokensOut()[0],
      0, // @audit `minTokenOut` is hardcoded to 0
      false
  );
  ```
* [`Pendle_Module::pendle_exit`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L202-L227), [L216](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L216):
  ```solidity
  router.exitPostExpToToken(
      address(this),
      market,
      amount,
      amountLp,
      IPRouter.TokenOutput({
          tokenOut: asset,
          minTokenOut: 0, // @audit `minTokenOut` hardcoded to 0
          tokenRedeemSy: asset,
          pendleSwap: address(0),
          swapData: IPSwapAggregator.SwapData({
              swapType: IPSwapAggregator.SwapType.NONE,
              extRouter: address(0),
              extCalldata: "",
              needScale: false
          })
      })
  );
  ```
이러한 모든 기능은 슬리피지 보호가 없는 트랜잭션을 허용하므로, MEV 봇에 의해 악용되어 D2 스테이커의 가치 손실을 초래할 수 있습니다.

**영향:** 슬리피지 보호의 부재는 프로토콜을 프론트 러닝 및 가격 조작에 노출시킵니다. 공격자는 이러한 하드코딩된 0 값을 이용하여 D2 스테이커의 비용으로 거래에서 가치를 추출하여 잠재적인 금전적 손실을 초래할 수 있습니다.


**권장 완화 방법:** 트레이더가 호출 시 `minAmountOut`을 제공하도록 허용하는 것을 고려하세요.


**D2:** [`cd7058d`](https://github.com/d2sd2s/d2-contracts/commit/cd7058d32ef80fa274851117ee8e5868ec52cc5b)에서 수정됨.

**Cyfrin:** 검증됨.


### `VaultV3`의 안전하지 않은 토큰 전송으로 인해 상태 불일치가 발생할 수 있음 (Unsafe token transfers in `VaultV3` can lead to state inconsistencies)

**설명:** `VaultV3` 계약은 `custodyFunds()` 및 `returnFunds()` 함수 모두에서 토큰 전송의 성공을 확인하지 않습니다. 상태 변경은 전송 성공 여부와 관계없이 발생하거나 그 전에 발생하므로 볼트 상태 불일치로 이어질 수 있습니다.

```solidity
function custodyFunds() external onlyTrader notCustodied duringEpoch returns (uint256) {
    uint256 amount = totalAssets();
    require(amount > 0, "!amount");
    custodied = true;
    custodiedAmount = amount;
    IERC20(asset()).transfer(trader, amount); // No success validation
    emit FundsCustodied(epochId, amount);
    return amount;
}

function returnFunds(uint256 _amount) external onlyTrader {
    require(custodied, "!custody");
    require(_amount > 0, "!amount");
    IERC20(asset()).transferFrom(trader, address(this), _amount); // No success validation
    epoch.epochEnd = uint80(block.timestamp);
    custodied = false;
    emit FundsReturned(currentEpoch, _amount);
}

```

**영향:** 신뢰할 수 있는 트레이더가 있더라도 몇 가지 악의적이지 않은 시나리오에서 이 문제가 발생할 수 있습니다:

1. 토큰 전송이 일시적으로 중지됨 (예: SVB 위기 동안의 USDC)
2. transferFrom에 대한 허용량이 누락되거나 불충분함
3. 토큰 블랙리스트 또는 전송 제한
4. revert 대신 false를 반환하는 토큰 구현

이 문제가 발생하면 다음과 같은 결과가 초래될 수 있습니다:

- 볼트가 custodied 상태에 갇힘
- 잘못된 에포크 전환
- 자산 회계 불일치
- 사용자 자금의 일시적 잠금
- 수동 거버넌스 개입 필요

**권장 완화 방법:** OpenZeppelin의 SafeERC20 라이브러리를 사용하고 Checks-Effects-Interactions 패턴을 따르세요:

```solidity
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract VaultV3 {
    using SafeERC20 for IERC20;

    function custodyFunds() external onlyTrader notCustodied duringEpoch returns (uint256) {
        uint256 amount = totalAssets();
        require(amount > 0, "!amount");
        custodied = true;
        custodiedAmount = amount;
        IERC20(asset()).safeTransfer(trader, amount);
        emit FundsCustodied(epochId, amount);
        return amount;
    }

    function returnFunds(uint256 _amount) external onlyTrader {
        require(custodied, "!custody");
        require(_amount > 0, "!amount");
        epoch.epochEnd = uint80(block.timestamp);
        custodied = false;
        IERC20(asset()).safeTransferFrom(trader, address(this), _amount);
        emit FundsReturned(currentEpoch, _amount);
    }
}

```

**D2:** [`e54eb5b`](https://github.com/d2sd2s/d2-contracts/commit/e54eb5b44e0407b367a8be16d8986c9456b8bc1e)에서 수정됨.

**Cyfrin:** 검증됨.


### 잘못된 `chainid`로 인해 Berachain에 올바른 Strategy 배포가 방지됨 (Incorrect `chainid` prevents correct Strategy deployment on Berachain)

**설명:** Strategy 계약에는 다양한 체인에 사용할 패싯(facet)을 지정하는 특수 구성이 포함되어 있습니다. 그러나 [`Strategy::constructor`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/Strategy.sol#L25-L337), [L216](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/Strategy.sol#L216)에서 볼 수 있듯이 Berachain에 할당된 `chainid`가 올바르지 않습니다:
```solidity
} else if (block.chainid == 80000) { // @audit Berachain id is 80094
```
[공식 문서](https://docs.berachain.com/developers/network-configurations)에 따르면 Berachain의 올바른 `chainid`는 `80000`이 아니라 `80094`입니다.

**영향:** Berachain에 배포하려는 패싯은 수정된 `chainid`로 새 Strategy 계약이 배포될 때까지 올바르게 초기화되지 않습니다. 이로 인해 Berachain에서 예상되는 기능이 실행되지 않습니다.

**권장 완화 방법:** `chainid`를 `80094`로 변경하는 것을 고려하세요:
```diff
- } else if (block.chainid == 80000) {
+ } else if (block.chainid == 80094) {
```

**D2:** 커밋 [`ab5b852`](https://github.com/d2sd2s/d2-contracts/commit/ab5b85264dd7fcacc4afc5e146427428b3f6f719)에서 수정됨.

**Cyfrin:** 검증됨.


### `ExchangeRouter::updateOrder`에 대한 잘못된 인터페이스로 인해 GMX V2에서 주문 업데이트가 방지됨 (Incorrect interface for `ExchangeRouter::updateOrder` prevents order updates in GMX V2)

**설명:** GMX V2 거래 플랫폼과의 통합, 특히 [`GMX_Module::gmxv2_update`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/GMXV2.sol#L140-L148) 함수에 문제가 있습니다:
```solidity
function gmxv2_update(
    bytes32 key,
    uint256 sizeDeltaUsd,
    uint256 acceptablePrice,
    uint256 triggerPrice,
    uint256 minOutputAmount
) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    exchangeRouter.updateOrder(key, sizeDeltaUsd, acceptablePrice, triggerPrice, minOutputAmount);
}
```

이 문제는 [`ExchangeRouter::updateOrder`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/GMXV2.sol#L383-L389)에 대한 잘못된 인터페이스 정의로 인해 발생합니다:

```solidity
function updateOrder(
    bytes32 key,
    uint256 sizeDeltaUsd,
    uint256 acceptablePrice,
    uint256 triggerPrice,
    uint256 minOutputAmount
) external payable;
```

그러나 [`ExchangeRouter`](https://arbiscan.io/address/0x900173a66dbd345006c51fa35fa3ab760fcd843b#code)에서 GMX가 사용하는 실제 함수 서명은 다음과 같습니다:

```solidity
function updateOrder(
    bytes32 key,
    uint256 sizeDeltaUsd,
    uint256 acceptablePrice,
    uint256 triggerPrice,
    uint256 minOutputAmount,
    uint256 validFromTime,
    bool autoCancel
) external payable nonReentrant {
```

예상 함수 서명과 실제 함수 서명 간의 불일치는 매개변수 누락으로 인해 `GMX_Module::gmxv2_update`에 대한 호출이 항상 revert됨을 의미합니다.

**영향:** `gmxv2_update` 함수는 작동하지 않으며 항상 revert되어 주문 업데이트를 방지합니다. 포지션을 닫고 다시 여는 것으로 이 문제를 우회할 수 있지만, 이 해결 방법은 비효율적이며 불필요한 거래 비용을 초래합니다.

**개념 증명 (Proof of Concept):** 다음 테스트는 문제를 강조합니다:
```solidity
function test_gmxv2_update_SucceedGivenValidOrder() public {
    // First create a long position
    uint256 collateralAmount = 1e18;
    uint256 sizeDeltaUsd = 10000e30;
    uint256 initialTriggerPrice = 2500e30;  // Current ETH price
    uint256 initialAcceptablePrice = 2400e30;  // Lower than trigger price for market long (willing to pay up to this price)
    uint256 initialMinOutputAmount = 0.9e18;
    uint256 executionFee = 0.1 ether;

    // Deal WETH to the strategy
    deal(WETH_ADDRESS, address(strategy), collateralAmount);

    // Create the order
    vm.prank(address(strategy));
    _weth.approve(GMX_ORDER_VAULT, collateralAmount);

    vm.recordLogs();
    // Create a market increase order
    vm.prank(EXECUTOR);
    _gmx.gmxv2_create{value: executionFee}(
        GMX_WETH_MARKET,
        WETH_ADDRESS,
        new address[](0), // No swap path
        IExchangeRouter.OrderType.LimitIncrease,
        IExchangeRouter.DecreasePositionSwapType.NoSwap,
        true, // isLong
        sizeDeltaUsd,
        collateralAmount,
        initialTriggerPrice,
        initialAcceptablePrice,
        initialMinOutputAmount,
        executionFee
    );
    Vm.Log[] memory entries = vm.getRecordedLogs();

    // Get the order key
    bytes32 key = entries[5].topics[2];

    // Wait for a few blocks to ensure order is ready
    vm.warp(block.timestamp + 1 hours);
    vm.roll(block.number + 100);

    // New parameters for the update
    uint256 newSizeDeltaUsd = 20000e30;
    uint256 newAcceptablePrice = 2200e30;
    uint256 newTriggerPrice = 2050e30;
    uint256 newMinOutputAmount = 0.95e18;

    // Record initial executor balance
    uint256 initialBalance = EXECUTOR.balance;

    // Update the order
    // This will fail because the interface used is not the correct one
    vm.prank(EXECUTOR);
    _gmx.gmxv2_update(
        key,
        newSizeDeltaUsd,
        newAcceptablePrice,
        newTriggerPrice,
        newMinOutputAmount
    );

    // Verify the executor spent the correct amount of ETH for execution fees
    assertEq(
        EXECUTOR.balance,
        initialBalance,
        "Executor balance should not change for updates"
    );
}
```

**권장 완화 방법:** 인터페이스를 변경하고 호출에 추가 매개변수를 추가하는 것을 고려하세요.

**D2:** [`23a48bc`](https://github.com/d2sd2s/d2-contracts/commit/23a48bc981540f66cb853857b9888373058a4930)에서 수정됨.

**Cyfrin:** 검증됨.


### Boost 통합 누락으로 인해 `Bera_Module`이 `BGTStaker`에 스테이킹하지 못함 (`Bera_Module` fails to stake in `BGTStaker` due to missing Boost integration)

**설명:** D2 Berachain 통합에는 [`Bera_Module::bera_bgt_stake`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L54-L56) 및 [`Bera_Module::bera_bgt_withdraw`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L58-L60)라는 두 가지 함수가 포함되어 있습니다. 이 함수들은 각각 [`BGTStaker::stake`](https://github.com/berachain/contracts/blob/main/src/pol/BGTStaker.sol#L93-L96) 및 [`BGTStaker::withdraw`](https://github.com/berachain/contracts/blob/main/src/pol/BGTStaker.sol#L98-L101)와 상호 작용하려고 시도합니다.

그러나 `BGTStaker::stake` 및 `BGTStaker::withdraw`는 [`onlyBGT`](https://github.com/berachain/contracts/blob/main/src/pol/BGTStaker.sol#L58-L62) modifier에 의해 강제되는 것처럼 `BGT` 토큰 계약 자체에서만 호출할 수 있습니다:

```
/// @dev Throws if called by any account other than BGT contract.
modifier onlyBGT() {
    if (msg.sender != address(stakeToken)) NotBGT.selector.revertWith();
    _;
}
...

function stake(address account, uint256 amount) external onlyBGT {
    _stake(account, amount);
}
```

`BGTStaker`에 스테이킹하려면 사용자는 `BGT` 토큰의 **부스트 기능**을 사용해야 합니다. 여기에는 다음이 포함됩니다:
1. 검증자를 부스트하기 위해 [`BGT::queueBoost`](https://github.com/berachain/contracts/blob/main/src/pol/BGT.sol#L216-L227) 및 [`BGT::activateBoost`](https://github.com/berachain/contracts/blob/main/src/pol/BGT.sol#L241-L266) 호출.
2. 부스트를 종료하기 위해 [`BGT::queueDropBoost`](https://github.com/berachain/contracts/blob/main/src/pol/BGT.sol#L268-L276) 및 [`BGT::dropBoost`](https://github.com/berachain/contracts/blob/main/src/pol/BGT.sol#L285-L306) 호출.

검증자 부스트에 대한 자세한 내용은 Berachain [문서](https://docs.berachain.com/learn/pol/tokens/bgt#boosting-validators-incentives)에서 찾을 수 있습니다.

**영향:** 프로토콜은 의도한 대로 `BGTStaker`에서 `$BGT` 보상을 얻을 수 없습니다. 이러한 보상에 액세스하려면 `BGTStaker`를 직접 호출하는 대신 `BGT` 토큰의 부스트 기능과 통합해야 합니다. 이 간과로 인해 스테이킹 인센티브를 놓치고 프로토콜의 전체 수입이 감소할 수 있습니다.

**권장 완화 방법:** BGT 토큰에 부스트 기능을 구현하는 것을 고려하세요.

**D2:** [`11c9407`](https://github.com/d2sd2s/d2-contracts/commit/11c9407644df2830f562cc60f4e0bfc1263459d3)에서 수정됨.

**Cyfrin:** 검증됨.


### `deadline` 매개변수로 인해 `Bera_Module::bera_kodiakv3_swap`이 손상됨 (`Bera_Module::bera_kodiakv3_swap` broken due to `deadline` parameter)

**설명:** `Bera_Module::bera_kodiakv3_swap` 함수는 스왑을 실행하기 위해 Kodiak의 `SwapRouter02::exactInput` (Uniswap V3와 유사)을 호출합니다:
```solidity
function bera_kodiakv3_swap(address token, uint amount, uint amountMin, bytes calldata path) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    validateToken(token);
    IERC20(token).approve(address(kodiakv3swap), amount);
    kodiakv3swap.exactInput(IKodiakV3.ExactInputParams({
        path: path,
        recipient: address(this),
        deadline: type(uint256).max,
        amountIn: amount,
        amountOutMinimum: amountMin
    }));
}
```
그러나 `deadline` 매개변수는 함수 호출에 포함되지만 [`SwapRouter02.ExactInputParams`](https://berascan.com/address/0xe301e48f77963d3f7dbd2a4796962bd7f3867fb4#code) 구조체에는 존재하지 않습니다:

```solidity
struct ExactInputParams {
    bytes path;
    address recipient;
    uint256 amountIn;
    uint256 amountOutMinimum;
}
```

결과적으로, `Bera_Module::bera_kodiakv3_swap`에 대한 모든 호출은 일치하지 않는 함수 매개변수로 인해 항상 revert됩니다.

**영향:** `bera_kodiakv3_swap`을 사용하는 모든 트랜잭션이 revert되므로 Kodiak V3를 통해 실행되는 스왑은 완전히 실패합니다.

**개념 증명 (Proof of Concept):** 다음 테스트는 실패하며 문제를 강조합니다:
```solidity
function test_bera_kodiakv3_swap() public {
    deal(WBERA_ADDRESS, address(strategy), 1e18);

    bytes memory path = abi.encodePacked(WBERA_ADDRESS, uint24(3000), HONEY_ADDRESS);

    vm.prank(EXECUTOR);
    bera.bera_kodiakv3_swap(
        WBERA_ADDRESS,
        1e18,
        0,
        path
    );

    assertGt(HONEY.balanceOf(address(strategy)),0);
}
```

**권장 완화 방법:** `IKodiakV3.ExactInputParams`에서 `deadline` 매개변수를 제거하는 것을 고려하세요. 또한 문제 _7.4.3 부적절한 기한(deadline) 처리_에서 논의된 대로 적절한 기한 처리를 보장하기 위해 호출에 전달할 수 있는 별도의 `deadline`을 추가하는 것을 고려하세요.


**D2:** [`84dbcf9`](https://github.com/d2sd2s/d2-contracts/commit/84dbcf92e7a8a4d84b68d39e8726281660aee2b7)에서 수정됨.

**Cyfrin:** 검증됨.


### Kodiak 스왑 함수가 출력 토큰 승인 여부를 확인하지 않아 자산이 묶일 위험이 있음 (Kodiak swap functions do not check if output token is approved, risking stuck assets)

**설명:** `Inch_Module` 내의 스왑 구현에서 입력 토큰과 출력 토큰 모두 스왑을 실행하기 전에 승인되었는지 확인합니다. 이 유효성 검사는 [`inch_swap`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Inch.sol#L48-L59), [`inch_uniswapV3Swap`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Inch.sol#L61-L84) 및 [`inch_clipperSwap`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Inch.sol#L86-L105)에 존재합니다.

그러나 이 유효성 검사는 [`Bera_Module::bera_kodiakv2_swap`](https://github.com/d2sd2s/d2-contracts/blob/main/contracts/modules/Bera.sol#L120-L130) 및 [`Bera_Module::bera_kodiakv3_swap`](https://github.com/d2sd2s/d2-contracts/blob/main/contracts/modules/Bera.sol#L188-L198) 모두에서 누락되었습니다.

결과적으로, 트레이더(`EXECUTOR_ROLE`)가 실수로 또는 의도적으로 승인되지 않은 토큰으로 스왑할 수 있습니다. 이 토큰은 **다시 스왑할 수 없으므로** Strategy 계약에 묶여 액세스할 수 없게 됩니다.

**영향:** 트레이더가 승인되지 않은 토큰으로 스왑하면 다시 스왑할 수 없으므로 계약에 영구적으로 묶이게 됩니다.

**개념 증명 (Proof of Concept):** 다음 테스트는 문제를 강조합니다:
```solidity
function test_bera_kodiakv2_swap_to_non_allowed_token() public {
    deal(WBERA_ADDRESS, address(strategy), 1e18);

    address[] memory path = new address[](2);
    path[0] = WBERA_ADDRESS;
    path[1] = RAMEN_TOKEN_ADDRESS; // not allowed

    vm.startPrank(EXECUTOR);
    bera.bera_kodiakv2_swap(
        WBERA_ADDRESS,
        1e18,
        0,
        path
    );

    uint256 ramenBalance = ERC20(RAMEN_TOKEN_ADDRESS).balanceOf(address(strategy));
    assertGt(ramenBalance,0);

    path[0] = RAMEN_TOKEN_ADDRESS;
    path[1] = WBERA_ADDRESS;

    // token cannot be swapped back
    vm.expectRevert("Invalid token");
    bera.bera_kodiakv2_swap(
        RAMEN_TOKEN_ADDRESS,
        ramenBalance,
        0,
        path
    );
    vm.stopPrank();

    // balance still left in contract
    assertEq(ERC20(RAMEN_TOKEN_ADDRESS).balanceOf(address(strategy)), ramenBalance);
}
```

**권장 완화 방법:** `Inch_Module` 스왑에서 수행되는 것처럼 입력 토큰 _및_ 출력 토큰을 모두 검증하는 것을 고려하세요.

**D2:** [`c70268c`](https://github.com/d2sd2s/d2-contracts/commit/c70268ca43bb3417958f72e51d7773f95425ca6e)에서 수정됨.

**Cyfrin:** 검증됨.

\clearpage
## Low Risk


### Aave 모듈에 보상 청구 기능이 부족함 (Aave’s module lacks reward-claiming functionality)

**설명:** D2 프로토콜의 Aave 통합에는 Aave_Module.sol 계약에 보상 청구 기능이 부족합니다. 프로토콜은 Aave의 대출 및 차입 기능과 성공적으로 상호 작용하지만, 이러한 활동에서 얻은 보상을 청구하거나 분배하는 메커니즘을 구현하지 않습니다.

계약에는 보상 청구에 필요한 Aave의 IncentivesController와 상호 작용하기 위한 인터페이스 정의와 구현이 모두 부족합니다. 결과적으로 대출 및 차입 활동에서 발생한 모든 보상은 Aave 프로토콜에 잠긴 상태로 유지됩니다.

**영향:** 보상 청구 기능의 부재는 다음과 같은 결과를 초래합니다:

1. **가치의 영구적인 손실**
    - 대출 및 차입 활동에서 얻은 모든 보상은 사실상 Aave 프로토콜에 잠깁니다.
    - 이러한 보상은 축적되지만 사용자와 프로토콜 모두 액세스할 수 없습니다.
    - 보상 청구 기능이 추가되지 않는 한 가치는 영구적으로 고립됩니다.
2. **프로토콜 수익 감소**
    - 프로토콜은 보상 토큰의 잠재적 수익 흐름을 놓칩니다.
    - 보상 토큰을 통한 재무 다각화 기회 상실

**권장 완화 방법:** 이를 해결하기 위해 다음 구현을 고려하세요:

1. 보상 청구를 활성화하기 위해 Aave의 IncentivesController와 통합
2. 청구된 보상을 사용자와 프로토콜 간에 공정하게 할당하는 보상 분배 시스템
3. 보상 수집을 최적화하기 위한 정기적인 자동 청구 메커니즘


**D2:** [`d3f76bb`](https://github.com/d2sd2s/d2-contracts/commit/d3f76bb009631b8a70fd21c47733336708a8030d)에서 수정됨.

**Cyfrin:** 검증됨.


### 손상된 트레이더 계정이 관리자의 액세스 취소를 차단할 수 있음 (Compromised trader account can block admin from revoking access)

**설명:** D2용 거래 전략 계약은 `ADMIN_ROLE`과 `EXECUTOR_ROLE`이라는 두 가지 역할을 정의합니다. `EXECUTOR_ROLE`은 스테이커를 대신하여 거래를 실행하는 책임이 있는 활성 당사자를 위한 것이며, `ADMIN_ROLE`은 주로 비상 개입을 위해 예약된 보다 수동적인 역할입니다.

문제는 [`Vault::initialize`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/VaultV3.sol#L61-L81)에서 발생하며, 여기서 `args.trader`에게 `ADMIN_ROLE`과 `EXECUTOR_ROLE`이 모두 [할당](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/VaultV3.sol#L71-L74)됩니다:
```solidity
s.grantRole(ADMIN_ROLE, args._owner);
s.grantRole(EXECUTOR_ROLE, args._owner);
s.grantRole(ADMIN_ROLE, args._trader); // @audit admin given to trader as well
s.grantRole(EXECUTOR_ROLE, args._trader);
```
이 설정은 보안 위험을 초래합니다. 트레이더의 계정이 손상되면 공격자가 소유자의 관리자 권한을 취소하여 `EXECUTOR_ROLE`에서 손상된 트레이더를 제거하지 못하게 할 수 있습니다.

**영향:** 트레이더 계정이 손상되면 프로토콜 관리자가 공격자가 액세스를 악용하기 전에 `EXECUTOR_ROLE`을 취소할 수 없을 수 있습니다. 이로 인해 승인되지 않거나 악의적인 거래가 발생하여 프로토콜과 이해 관계자에게 잠재적인 해를 끼칠 수 있습니다.


**권장 완화 방법:** `args.trader`에게 `ADMIN_ROLE`을 할당하지 않는 것을 고려하세요:
```diff
  s.grantRole(ADMIN_ROLE, args._owner);
  s.grantRole(EXECUTOR_ROLE, args._owner);
- s.grantRole(ADMIN_ROLE, args._trader);
  s.grantRole(EXECUTOR_ROLE, args._trader);
```


**D2:** [`614daaa`](https://github.com/d2sd2s/d2-contracts/commit/614daaaf2a1a4fddf7c8b070280f4b9cf102bb07)에서 수정됨.

**Cyfrin:** 검증됨.


### 부적절한 기한(deadline) 처리 (Improper deadline handling)

**설명:** Bera 모듈은 DEX 작업에서 트랜잭션 기한을 부적절하게 처리하는 것을 보여줍니다:

- KodiakV2/V3 작업은 `type(uint256).max`를 기한으로 사용합니다:

```solidity
// Bera.sol
function bera_kodiakv2_add(...) {
    kodiakv2.addLiquidity(..., type(uint256).max);
}

function bera_kodiakv2_swap(address token, uint amount, uint amountMin, address[] calldata path) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    ...
    kodiakv2.swapExactTokensForTokensSupportingFeeOnTransferTokens(
        ...
        type(uint256).max
    );
}

function bera_kodiakv3_increase(...) {
    kodiakv3.increaseLiquidity(IKodiakV3.IncreaseLiquidityParams({
        ...
        deadline: type(uint256).max
    }));
}
```

- OogaBooga 및 KodiakV3(문제 _7.3.6 `Bera_Module::bera_kodiakv3_swap` broken due to `deadline` parameter_ 참조) 스왑에는 기한 보호가 전혀 없습니다:

```solidity
function bera_oogabooga_swap(...) {
    oogaBooga.swap(tokenInfo, pathDefinition, executor, referralCode);
}
```

무한한 기한을 사용하거나 기한을 전혀 사용하지 않는 것은 DeFi에서 위험한 관행입니다. 트랜잭션 기한은 특히 네트워크 혼잡이나 높은 변동성 기간 동안 예상치 못한 시장 상황에서 거래가 실행되는 것을 방지하는 중요한 보호 메커니즘입니다.

**영향:** 액세스가 EXECUTOR_ROLE로 제한되지만 부적절한 기한 처리는 다음과 같은 결과를 초래할 수 있습니다:

- 네트워크 혼잡 중 예상치 못한 시간에 거래 실행
- 불안정한 시장 상황에서 오래된 트랜잭션에 대한 보호 없음
- MEV 봇이 트랜잭션을 보류하고 불리한 순간에 실행할 수 있음
- 오래된 거래를 무효화할 메커니즘 없음

OogaBooga의 경우 특히 프로토콜 설계에 기한 매개변수가 없으면 사용자는 자신을 보호할 방법 없이 이러한 위험에 노출됩니다.

**권장 완화 방법:**
- Kodiak 작업의 경우 합리적인 기한을 구현하세요:

```solidity
uint256 private constant MAX_DEADLINE_WINDOW = 30 minutes;

function bera_kodiakv2_add(...) {
    kodiakv2.addLiquidity(..., block.timestamp + MAX_DEADLINE_WINDOW);
}
```

- OogaBooga 및 Kodiak V3의 경우 기한 보호를 추가하는 래퍼(wrapper)를 구현하는 것을 고려하세요:

```solidity
function bera_oogabooga_swap(..., uint256 deadline) {
   require(block.timestamp <= deadline, "Expired");
    oogaBooga.swap(...);
}

function bera_kodiakv3_swap(..., uint256 deadline) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    require(block.timestamp <= deadline, "Expired");
    ...
    kodiakv3swap.exactInput(IKodiakV3.ExactInputParams({
        ...
    }));
}
```

**D2:** 메인 체인인 Arbitrum에서는 크게 신경 쓰지 않으므로 "부적절한 기한 처리"를 무시했습니다. Mainnet에서는 더 위험하다는 것을 이해하고 있습니다.

**Cyfrin:** 인지함.


### 중요한 상태 변경에 대한 이벤트 누락 (Missing events for important state changes)

**설명:** 다음 호출은 계약 내부의 중요한 상태를 변경함에도 불구하고 이벤트가 방출되지 않습니다:
* `Strategy::claim`
* `Strategy::setFrozen`
* `Strategy::setSelector`
* `VaultV3::emergencyFreeze`


**권장 완화 방법:** 위의 호출에서 이벤트가 방출되도록 추가하는 것을 고려하세요. 이는 전략이 언제 누구에 의해 청구되었는지에 대한 명확한 온체인 기록을 제공하여 투명성과 감사 가능성을 향상시킵니다.


**D2:** 해당 호출을 곧 제거할 예정이므로 "중요한 상태 변경에 대한 이벤트 누락"을 무시했습니다.

**Cyfrin:** 인지함.


### 승인이 잘못된 계약에 대해 이루어져 `Silo_Module::silo_execute`가 revert됨 (`Silo_Module::silo_execute` will revert as approval is to the wrong contract)

**설명:** D2는 Silo 계약과의 통신을 용이하게 하는 [`Silo_Module`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Silo.sol)을 통해 대출 프로토콜 [Silo](https://www.silo.finance/)와 통합됩니다.

이 모듈의 함수 중 하나는 [`Silo_Module::silo_execute`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Silo.sol#L55-L58)이며, 가스 사용을 최적화하기 위해 여러 호출을 묶어 Silo 라우터로 보낼 수 있습니다:

```solidity
function silo_execute(ISiloRouter.Action[] calldata actions) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    // @audit approval should be to `address(router)` as it is the one facilitating the actions
    IERC20(actions[0].asset).approve(actions[0].silo, actions[0].amount);
    router.execute(actions);
}
```
여기서 문제는 승인이 `actions[0].silo`에 잘못 부여되었지만, 모든 토큰 전송을 처리하는 책임이 있는 계약이므로 `router`에 부여되어야 한다는 것입니다.

**영향:** `silo_execute` 함수는 잘못된 승인으로 인해 실패합니다. 이는 `Silo_Module`의 전체 기능에 영향을 미치지는 않지만(모든 필요한 작업을 별도로 실행할 수 있으므로), 트랜잭션을 묶어 얻을 수 있는 가스 절감 효과가 사라져 트랜잭션 비용이 높아집니다.

**개념 증명 (Proof of Concept):** 다음 테스트는 문제를 강조합니다:
```solidity
function test_silo_execute() public {
    deal(WETH_ADDRESS,address(strategy),1e18);

    ISiloRouter.Action[] memory actions = new ISiloRouter.Action[](4);
    actions[0] = ISiloRouter.Action(ISiloRouter.ActionType.Deposit, GMX_SILO, WETH_ADDRESS, 1e18, false);
    actions[1] = ISiloRouter.Action(ISiloRouter.ActionType.Borrow, GMX_SILO, GMX_ADDRESS, 100e18, false);
    actions[2] = ISiloRouter.Action(ISiloRouter.ActionType.Repay, GMX_SILO, GMX_ADDRESS, 100e18, false);
    actions[3] = ISiloRouter.Action(ISiloRouter.ActionType.Withdraw, GMX_SILO, WETH_ADDRESS, 1e18-1, false);

    vm.prank(EXECUTOR);
    silo.silo_execute(actions);

    assertEq(gmxDebtToken.balanceOf(address(strategy)), 1);
    assertEq(gmxCollateralToken.balanceOf(address(strategy)), 0);
    assertEq(wethCollateralToken.balanceOf(address(strategy)), 0);
    assertEq(address(strategy).balance, 1e18-1);
}
```

**권장 완화 방법:** 대신 `router`를 승인하는 것을 고려하세요:
```diff
- IERC20(actions[0].asset).approve(actions[0].silo, actions[0].amount);
+ IERC20(actions[0].asset).approve(address(router), actions[0].amount);
```

**D2:** [`ea03f4d`](https://github.com/d2sd2s/d2-contracts/commit/ea03f4d4b5baf1436a7c49e789a499b489713606)에서 수정됨.

**Cyfrin:** 검증됨.


### Silo와 Dolomite에 LTV 제한이 없어 청산 위험이 증가함 (Silo and Dolomite lack LTV limit increasing liquidation risk)

**설명:** Aave에서 차입할 때, [`Aave_Module::aave_borrow`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Aave.sol#L51-L54)에서 담보 인정 비율(LTV)이 `MAX_LTV_FACTOR`(80%) 미만으로 유지되도록 하는 확인이 있습니다:

```solidity
pool.borrow(asset, amount, interestRateMode, referralCode, onBehalfOf);
(uint256 totalCollateralBase, uint256 totalDebtBase, , , uint256 ltv, ) = pool.getUserAccountData(onBehalfOf);
uint256 maxDebtBase = (totalCollateralBase * ltv * MAX_LTV_FACTOR) / (BASIS_FACTOR * MANTISSA_FACTOR);
require(totalDebtBase <= maxDebtBase, "borrow amount exceeds max LTV");
```

그러나 이 LTV 확인은 대출 프로토콜이기도 한 [`Silo_Module::silo_borrow`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Silo.sol#L44-L47) 및 [`Dolomite_Module::dolomite_openBorrowPosition`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L208-L216)/[`dolomite_transferBetweenAccounts`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L226-L234)에서 누락되었습니다. 결과적으로 이러한 플랫폼에서 80%보다 높은 LTV를 가진 포지션을 열 수 있습니다.

**영향:** Silo와 Dolomite가 동일한 80% LTV 제한을 강제하지 않으므로 더 높은 위험 포지션에 진입할 수 있습니다. 이는 예상치 못한 청산 가능성을 높여 사용자를 불필요한 재정적 위험에 노출시킵니다.

**권장 완화 방법:** Silo와 Dolomite에 대해 동일한 LTV 확인을 구현하는 것을 고려하세요.

**D2:** 트레이더가 무모하지 않다고 가정하고 "Silo와 Dolomite에 LTV 제한이 없어 청산 위험이 증가함"을 무시했습니다.

**Cyfrin:** 인지함.


### 승인되지 않은 토큰을 차입하면 거래 제한을 우회할 수 있음 (Borrowing non-approved tokens can bypass trading restrictions)

**설명:** `Inch_Module` 스왑 함수에서 출력 토큰은 프로토콜에 의해 승인되었는지 확인하기 위해 검증됩니다. 이 유효성 검사는 사전 승인된 토큰만 거래될 것이라는 신뢰를 유지하는 데 도움이 됩니다.

그러나 트레이더는 여전히 승인되지 않은 토큰을 차입하여 이 제한을 우회할 수 있습니다. 이는 승인된 토큰만 Strategy 계약에서 사용하거나 보유할 수 있다는 가정을 약화시킵니다.

**영향:** 트레이더가 승인되지 않은 토큰을 차입하여 보유하는 경우 승인된 토큰만 거래에 사용될 것이라는 기대가 위반될 수 있습니다. 이는 프로토콜의 자산 통제를 약화시키고 예상치 못한 위험을 초래할 수 있습니다.

**권장 완화 방법:** Aave, Silo 및 Dolomite에서 차입한 토큰도 승인된 토큰인지 확인하는 것을 고려하세요.


**D2:** Aave와 Silo에 대해 [`1704b31`](https://github.com/d2sd2s/d2-contracts/commit/1704b315b576175932abf11ff50252007cc2d702)에서 수정되었으며, Dolomite는 인지했습니다.

**Cyfrin:** 검증됨.

\clearpage
## Informational


### `Dolomite_Module`의 `ETH` 호출은 Dolomite에 해당 호출이 없음 (`ETH` calls on `Dolomite_Module` have no corresponding calls on Dolomite)

**설명:** 다음 호출은 Dolomite [배포된 계약](https://berascan.com/address/0xd6a31b6aea4d26a19bf479b5032d9ddc481187e6#writeContract)에 해당 호출이 없습니다:
* [`Dolomite_Module::dolomite_depositETH`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L127-L131)
* [`Dolomite_Module::dolomite_withdrawETH`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L153-L159)
* [`Dolomite_Module::dolomite_depositETHIntoDefaultAccount`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L140-L142)
* [`Dolomite_Module::dolomite_withdrawETHFromDefaultAccount`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L169-L174)

제거하는 것을 고려하세요.

**D2:** [`dc68fe8`](https://github.com/d2sd2s/d2-contracts/commit/dc68fe87fbe6ae605b4e0e6489db3ba65f905e15)에서 제거됨.

**Cyfrin:** 검증됨.


### `Bera_Module::bera_infrared_stake`의 불필요한 유효성 검사는 표준 패턴을 따라야 함 (Unnecessary validation in `Bera_Module::bera_infrared_stake` should follow standard pattern)

**설명:** [`Bera_Module::bera_infrared_stake`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Bera.sol#L78-L82)에는 `validateToken(vault)`에 대한 호출이 있습니다:

```solidity
function bera_infrared_stake(address vault, address token, uint256 amount) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    validateToken(vault); // @audit unnecessary
    IERC20(token).approve(vault, amount);
    IInfraredVault(vault).stake(amount);
}
```

이는 유효성 검사가 `token`이 아닌 `vault`에 적용되기 때문에 이례적입니다. 또한 `token`은 이미 계약에 존재해야 하며, 그러기 위해서는 `allowedTokens`에 포함되어야 하므로 확인이 불필요합니다.

그러나 `validateToken(vault)` 함수는 목적이 있습니다. 트레이더가 악의적인 `vault` 계약을 사용하는 것을 방지합니다. 따라서 대상은 여전히 검증되어야 하지만 보다 적절한 접근 방식을 사용해야 합니다. 이 패턴은 이미 코드베이스의 다른 부분에 확립되어 있으며, 여기서 유효성 검사는 [`TraderV0::approve`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Trader.sol#L1958-L1963) 함수 내부에서 수행됩니다. 일관성을 유지하기 위해 여기서도 동일한 접근 방식을 따르는 것이 좋습니다.

`validateToken(vault);` 호출과 승인을 모두 제거하는 것을 고려하세요:

```diff
function bera_infrared_stake(address vault, address token, uint256 amount) external onlyRole(EXECUTOR_ROLE) nonReentrant {
-   validateToken(vault);
-   IERC20(token).approve(vault, amount);
    IInfraredVault(vault).stake(amount);
}
```

**D2:** [`b0c4c4b`](https://github.com/d2sd2s/d2-contracts/commit/b0c4c4b11da647555a126eebd4e61104bb8ab718)에서 수정됨.

**Cyfrin:** 검증됨.


### 사용되지 않는 import (Unused imports)

**설명:** 계약에 사용되지 않는 import가 몇 가지 있습니다:

```solidity
import "@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol";
import "@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol";
```

이들은 다음에서 import됩니다:
* [`Dolomite.sol#L6-L7`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L6-L7)
 * [`Dolomite.sol#L6-L7`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Dolomite.sol#L6-L7), 여기서 `GMXV2_Cutter`가 사용하지만 이 추상 계약도 사용되지 않으므로 제거할 수 있습니다.
 * [`Pendle.sol#L6-L7`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Pendle.sol#L6-L7)
* [`Silo.sol#L6-L7`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Silo.sol#L6-L7)
* [`WETH.sol#L6-L7`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/WETH.sol#L6-L7)

또한, `D2OFT.sol#L4`의 [`Ownable` import](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/D2OFT.sol#L4)는 사용되지 않습니다:
```solidity
import "@openzeppelin/contracts/access/Ownable.sol";
```

이것들을 제거하는 것을 고려하세요.


**D2:** [`8880a91`](https://github.com/d2sd2s/d2-contracts/commit/8880a9180452afda8d246c4b84d7494bfa2ad443)에서 제거됨.

**Cyfrin:** 검증됨.


### Aave `swapBorrowRateMode`는 더 이상 사용되지 않음(deprecated) (Aave `swapBorrowRateMode` is deprecated)

**설명:** `Aave_Module`에는 [`aave_swapBorrowRateMode`](https://github.com/d2sd2s/d2-contracts/blob/c2fc257605ebc725525028a5c17f30c74202010b/contracts/modules/Aave.sol#L67-L69) 호출이 있습니다:
```solidity
function aave_swapBorrowRateMode(address asset, uint256 interestRateMode) external onlyRole(EXECUTOR_ROLE) nonReentrant {
    pool.swapBorrowRateMode(asset, interestRateMode);
}
```
그러나 `swapBorrowRateMode` 호출은 [deprecated](https://governance.aave.com/t/bgd-full-deprecation-of-stable-rate/16473)되었으며, [v2 풀](https://etherscan.io/address/0x7d2768de32b0b80b7a3454c06bdac94a69ddc7a9#writeProxyContract)의 호출로만 존재합니다.

이 호출을 제거하는 것을 고려하세요.


**D2:** [`cbcddab`](https://github.com/d2sd2s/d2-contracts/commit/cbcddab7dd386c66cccf0a1073ba1c666fc9a365)에서 제거됨.

**Cyfrin:** 검증됨.


### `Bera_Module::bera_kodiakv2_swap` 및 `bera_kodiakv3_swap`에 대한 선택자를 별도로 추가해야 함 (Selectors for `Bera_Module::bera_kodiakv2_swap` and `bera_kodiakv3_swap` needs to be separately added)

**설명:** `Strategy::constructor`에서 거의 모든 기존 패싯 선택자가 `s.selectors` 매핑에 추가되며, 이는 폴백(fallback) 함수에서 올바른 패싯으로 호출을 지시하는 데 사용됩니다.

거의 모든 항목이 포함되지만, `Bera_Module::bera_kodiakv2_swap` 및 `bera_kodiakv3_swap`은 여기에 없으므로 역할 `0x00`(`DEFAULT_ADMIN_ROLE`)으로 제한된 `Strategy::setSelector` 호출을 사용하여 별도로 추가해야 합니다.

대신 `Strategy::constructor`의 일반 선택자 할당에 이를 포함하는 것을 고려하세요. 따라서 두 번의 호출을 절약할 수 있습니다.


**D2:** [`5e22afc`](https://github.com/d2sd2s/d2-contracts/commit/5e22afc1995cf93930ddb738b9e9427846f14515)에서 추가됨.

**Cyfrin:** 검증됨.


### Ownable 대신 Ownable2Step 사용 고려 (Consider using Ownable2Step instead of Ownable)

**설명:** `VaultV3` 및 `VaultV0` 계약은 액세스 제어를 위해 OpenZeppelin의 `Ownable`을 사용합니다. 안전하지만 이 단일 단계 소유권 이전 패턴은 소유권이 실수로 유효하지 않거나 액세스할 수 없는 주소로 이전되는 경우 계약을 영구적으로 잠글 위험이 있습니다.

대신 `Ownable2Step`을 사용하는 것을 고려하세요. 이는 새 소유자가 별도의 트랜잭션에서 소유권을 수락해야 합니다. 이 2단계 패턴은 우발적인 전송을 방지하고 새 소유자가 실제로 계약과 상호 작용할 수 있도록 보장하므로 모범 사례로 간주됩니다.

**D2:** "Ownable 대신 Ownable2Step 사용 고려"를 무시했습니다. 나중에 고려할 것입니다.

**Cyfrin:** 인지함.

\clearpage
